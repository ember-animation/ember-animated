{"version":3,"file":"sprite.js","sources":["../../src/-private/sprite.ts"],"sourcesContent":["import { warn } from '@ember/debug';\nimport Ember from 'ember';\nimport Transform, { ownTransform, cumulativeTransform } from './transform.ts';\nimport { continueMotions } from './motion-bridge.ts';\nimport { collapsedChildren } from './margin-collapse.ts';\nimport {\n  shiftedBounds,\n  relativeBounds,\n  resizedBounds,\n  emptyBounds,\n} from './bounds.ts';\nimport type Child from './child.ts';\nimport { getOrCreate } from './singleton.ts';\n\nconst inFlight = getOrCreate('sprite', () => new WeakMap());\n\n/**\n  A Sprite is our handle to a DOM element that we want to animate.\n\n  It manages locking and unlocking the element (which means taking it\n  in and out of static document flow so it's readily animatable).\n\n  It tracks the sprite's current transform.\n\n  It tracks the sprite's initial and/or final bounds, as measured\n  from the actual pre- and/or post-animation DOM.\n\n  @class Sprite\n*/\nexport default class Sprite {\n  static offsetParentStartingAt(element: Element) {\n    let parent = getEffectiveOffsetParent(element as HTMLElement);\n    if (!parent) {\n      parent = document.getElementsByTagName('body')[0] as Element;\n    }\n    return new this(parent, true, null, null);\n  }\n\n  static offsetParentEndingAt(element: Element) {\n    let parent = getEffectiveOffsetParent(element as HTMLElement);\n    if (!parent) {\n      parent = document.getElementsByTagName('body')[0] as Element;\n    }\n    return new this(parent, false, null, null);\n  }\n\n  static positionedStartingAt(element: Element, offsetSprite: Sprite) {\n    if (!offsetSprite.initialBounds) {\n      throw new Error('offset sprite must have initial bounds');\n    }\n    return new this(element, true, 'position', offsetSprite);\n  }\n\n  static positionedEndingAt(element: Element, offsetSprite: Sprite) {\n    if (!offsetSprite.finalBounds) {\n      throw new Error('offset sprite must have final bounds');\n    }\n    return new this(element, false, 'position', offsetSprite);\n  }\n\n  static sizedStartingAt(element: Element) {\n    return new this(element, true, 'size', null);\n  }\n\n  static sizedEndingAt(element: Element) {\n    let sprite = new this(element, false, 'size', null);\n    sprite._initialBounds = emptyBounds;\n    sprite._initialComputedStyle = sprite._finalComputedStyle;\n    sprite._initialPosition = sprite._finalPosition;\n    sprite._originalInitialBounds = sprite._initialBounds;\n    sprite._initialCumulativeTransform = sprite._finalCumulativeTransform;\n    return sprite;\n  }\n\n  private __element!: Element;\n\n  owner: Child | null = null;\n\n  private _transform: Transform | null = null;\n  private _cumulativeTransform: Transform | null = null;\n  private _offsetSprite: Sprite | null;\n  private _lockedToInitialPosition: boolean;\n  private _finalComputedStyle: CopiedCSS | null = null;\n  private _finalBounds: DOMRect | null = null;\n  private _originalFinalBounds: DOMRect | null = null;\n  private _finalPosition: SpritePosition | null = null;\n  private _finalCumulativeTransform: Transform | null = null;\n  private _initialComputedStyle: CopiedCSS | null = null;\n  private _initialBounds: DOMRect | null = null;\n  private _originalInitialBounds: DOMRect | null = null;\n  private _initialPosition: SpritePosition | null = null;\n  private _initialCumulativeTransform: Transform | null = null;\n  private _revealed: unknown;\n  private _imposedStyle: { [property: string]: string } | null = null;\n  private _styleCache: { [property: string]: string } | null = null;\n  private _collapsingChildren: Element[] | null = null;\n  private _lockMode: 'position' | 'size' | null;\n  private _inInitialPosition = false;\n\n  constructor(\n    element: Element,\n    inInitialPosition: boolean,\n    lockMode: 'position' | 'size' | null,\n    offsetSprite: Sprite | null,\n  ) {\n    this.element = element;\n    this._offsetSprite = offsetSprite;\n\n    this._lockedToInitialPosition = inInitialPosition;\n    if (inInitialPosition) {\n      this.measureInitialBounds();\n    } else {\n      this.measureFinalBounds();\n    }\n\n    let predecessor = inFlight.get(element);\n    if (predecessor && lockMode) {\n      // When we finish, we want to be able to set the style back to\n      // whatever it was before any Sprites starting locking things,\n      // so inheriting the state from our predecessor is important for\n      // correctness.\n      this._styleCache = predecessor._styleCache;\n      this._revealed = predecessor._revealed;\n      this._imposedStyle = predecessor._imposedStyle;\n      this._collapsingChildren = predecessor._collapsingChildren;\n      this._lockMode = predecessor._lockMode;\n      if (lockMode !== predecessor._lockMode) {\n        throw new Error(\n          `probable bug in ember-animated: can't change lock mode from ${predecessor._lockMode} to ${lockMode}`,\n        );\n      }\n    } else {\n      this._styleCache = null;\n      this._revealed = null;\n      this._lockMode = lockMode;\n      if (lockMode === 'position') {\n        this._rememberPosition();\n        this._cacheOriginalStyles();\n      } else if (this._lockMode === 'size') {\n        this._rememberSize();\n        this._cacheOriginalStyles();\n      }\n    }\n\n    if (Ember.testing) {\n      Object.seal(this);\n    }\n  }\n\n  /**\n    A DOMRect representing the place where this sprite will start the\n    transition.\n\n    ```js\n    sprite.initialBounds;\n    // { top: 0, bottom: 230, left: 0, right: 256, width: 256 }\n    ```\n\n    Not every sprite has initialBounds (a newly inserted\n    sprite will not -- it will only have finalBounds).\n\n    The position is measured *relative* to our offsetParent, if we\n    have one. Most of the time we want motions to act in relative\n    terms, so that if we're inside another animator things still work\n    out correctly.\n\n    You can manipulate initialBounds using methods like startAtPixel.\n\n    Motions should look at initialBounds and finalBounds to decide\n    what to do.\n\n    @accessor initialBounds\n    @type {DOMRect}\n  */\n  get initialBounds() {\n    return this._initialBounds;\n  }\n\n  /**\n    Like initialBounds, but relative to the screen, not the offset\n    parent. Most of the time you *don't* want this one, because your\n    motion will be more robust to ancestor motion if you do\n    everything in relative terms.\n\n    @accessor absoluteInitialBounds\n    @type {DOMRect}\n  */\n  get absoluteInitialBounds(): DOMRect {\n    if (this._offsetSprite) {\n      return shiftedBounds(\n        this._initialBounds!,\n        this._offsetSprite.initialBounds!.left,\n        this._offsetSprite.initialBounds!.top,\n      );\n    } else {\n      return this._initialBounds!;\n    }\n  }\n\n  /**\n    A DOMRect representing the place where this sprite will end the\n    transition. Not every sprite has finalBounds (a sprite that is\n    about to be destroyed will not -- it will only have\n    initialBounds).\n\n    The position is measured *relative* to our offsetParent, if we\n    have one. Most of the time we want motions to act in relative\n    terms, so that if we're inside another animator things still work\n    out correctly.\n\n    You can manipulate finalBounds using methods like endAtPixel.\n    @accessor finalBounds\n    @type {DOMRect}\n  */\n  get finalBounds() {\n    return this._finalBounds;\n  }\n\n  /**\n    Like initialBounds, but relative to the screen, not the offset\n    parent. Most of the time you *don't* want this one, because your\n    motion will be more robust to ancestor motion if you do\n    everything in relative terms.\n\n    @accessor absoluteFinalBounds\n    @type {DOMRect}\n  */\n  get absoluteFinalBounds() {\n    if (this._offsetSprite) {\n      return shiftedBounds(\n        this._finalBounds!,\n        this._offsetSprite.finalBounds!.left,\n        this._offsetSprite.finalBounds!.top,\n      );\n    } else {\n      return this._finalBounds;\n    }\n  }\n\n  /**\n    A snapshot of the sprite's computed style at the start of the\n    transition. We don't copy every possible property, see\n    CopiedCSS.\n\n    This is powered by getComputedStyle, so the property names and\n    values will follow those semantics.\n\n    Not every sprite will have an initialComputedStyle\n    (`insertedSprites` do not).\n\n    @accessor initialComputedStyle\n    @type {CSSStyleDeclaration}\n  */\n  get initialComputedStyle() {\n    return this._initialComputedStyle;\n  }\n\n  /**\n    A snapshot of the sprite's computed style at the end of the\n    transition. We don't copy every possible property, see\n    CopiedCSS.\n\n    This is powered by getComputedStyle, so the property names and\n    values will follow those semantics.\n\n    Not every sprite will have a finalComputedStyle\n    (`removedSprites` do not).\n\n    @accessor finalComputedStyle\n    @type {CSSStyleDeclaration}\n  */\n  get finalComputedStyle() {\n    return this._finalComputedStyle;\n  }\n\n  /**\n    Returns the attribute value from the initial position object with the\n    given `name`.\n\n    _This is mostly intended for use with SVG, where you can say things\n    like `getInitialDimension('x')`._\n\n    @method getInitialDimension\n    @param {string} name The desired attribute name.\n    @return {number|string}\n  */\n  getInitialDimension<K extends keyof SpritePosition>(\n    name: K,\n  ): SpritePosition[K] {\n    return this._initialPosition![name];\n  }\n\n  /**\n    Returns the attribute value from the final position object with the\n    given `name`.\n\n    _This is mostly intended for use with SVG, where you can say things\n    like `getFinalDimension('x')`._\n\n    @method getFinalDimension\n    @param {string} name The desired attribute name.\n    @return {number|string}\n  */\n  getFinalDimension<K extends keyof SpritePosition>(\n    name: K,\n  ): SpritePosition[K] {\n    return this._finalPosition![name];\n  }\n\n  /**\n    Analogous to initialBounds, this is a snapshot of the cumulative\n    effect of all transforms on this sprite at the start of\n    animation.\n\n    @method initialCumulativeTransform\n    @return {Transform}\n  */\n  get initialCumulativeTransform() {\n    return this._initialCumulativeTransform;\n  }\n\n  /**\n    Analogous to finalBounds, this is a snapshot of the cumulative\n    effect of all transforms on this sprite at the end of animation.\n\n    @method finalCumulativeTransform\n    @return {Transform}\n  */\n  get finalCumulativeTransform() {\n    return this._finalCumulativeTransform;\n  }\n\n  /**\n    Some things methods (like startAtSprite, startAtPixel, etc) can\n    set or alter the initialBounds. This gives you access to the\n    original value (which may be undefined if this sprite didn't have\n    any initial bounds, which is the case for newly inserted\n    sprites).\n\n    @method originalInitialBounds\n    @return {DOMRect}\n  */\n  get originalInitialBounds() {\n    return this._originalInitialBounds;\n  }\n\n  /**\n    Some things (like endAtSprite) can alter the finalBounds. This\n    gives you access to the original value (which may be undefined if\n    the sprite didn't have any final bounds, which is the case for\n    removedSprites).\n\n    @method originalFinalBounds\n    @return {DOMRect}\n  */\n  get originalFinalBounds() {\n    return this._originalFinalBounds;\n  }\n\n  // TODO: this is used only in tests, and it's a temptation toward DOM thrashing. Remove it.\n  getCurrentBounds(): DOMRect | undefined {\n    if (this._offsetSprite) {\n      return relativeBounds(\n        this.element.getBoundingClientRect() as DOMRect,\n        this._offsetSprite.getCurrentBounds()!,\n      );\n    } else {\n      return this.element.getBoundingClientRect() as DOMRect;\n    }\n  }\n\n  /**\n    Returns the current position of the element as an object.\n\n    _This deliberately only tracks inline styles, because it's only\n    important when the user is manipulating inline styles._\n\n    @private\n    @hide\n    @method _getCurrentPosition\n    @return {Object}\n  */\n  _getCurrentPosition(): SpritePosition {\n    let { element } = this;\n    if (isSVG(element)) {\n      let position: SVGPosition = {\n        x: getSVGLength(element, 'x'),\n        y: getSVGLength(element, 'y'),\n        cx: getSVGLength(element, 'cx'),\n        cy: getSVGLength(element, 'cy'),\n        r: getSVGLength(element, 'r'),\n        width: getSVGLength(element, 'width'),\n        height: getSVGLength(element, 'height'),\n        transform: element.getAttribute('transform'),\n      };\n      return position;\n    } else {\n      let style = (this.element as HTMLElement).style;\n      let position: HTMLPosition = {\n        top: style.top,\n        left: style.left,\n        bottom: style.bottom,\n        right: style.right,\n        transform: style.transform,\n        classList: Array.from(this.element.classList),\n      };\n      return position;\n    }\n  }\n\n  /**\n    Sets the position of the element.\n\n    @private\n    @method _reapplyPosition\n    @hide\n    @param {Object} pos The position to apply.\n    @return {void}\n  */\n  _reapplyPosition(pos: SpritePosition) {\n    if (!pos) {\n      return;\n    }\n    if (isSVG(this.element)) {\n      let { element } = this;\n      setSVGLength(element, 'x', pos);\n      setSVGLength(element, 'y', pos);\n      setSVGLength(element, 'cx', pos);\n      setSVGLength(element, 'cy', pos);\n      setSVGLength(element, 'r', pos);\n      setSVGLength(element, 'width', pos);\n      setSVGLength(element, 'height', pos);\n      setAttribute(element, 'transform', pos);\n    } else {\n      let style = (this.element as HTMLElement).style;\n      let p = pos as HTMLPosition;\n      style.top = p.top ?? '';\n      style.left = p.left ?? '';\n      style.right = p.right ?? '';\n      style.bottom = p.bottom ?? '';\n      style.transform = p.transform ?? '';\n\n      for (let cls of p.classList) {\n        this.element.classList.add(cls);\n      }\n      for (let cls of Array.from(this.element.classList)) {\n        if (!p.classList.includes(cls)) {\n          this.element.classList.remove(cls);\n        }\n      }\n    }\n  }\n\n  measureInitialBounds() {\n    if (this._initialBounds) {\n      throw new Error('Sprite already has initial bounds');\n    }\n    this._inInitialPosition = true;\n    if (this._offsetSprite) {\n      this._initialBounds = relativeBounds(\n        this.element.getBoundingClientRect() as DOMRect,\n        this._offsetSprite.initialBounds!,\n      );\n    } else {\n      this._initialBounds = this.element.getBoundingClientRect() as DOMRect;\n    }\n    this._initialComputedStyle = copyComputedStyle(this.element);\n    this._initialPosition = this._getCurrentPosition();\n    this._originalInitialBounds = this._initialBounds;\n    this._initialCumulativeTransform = cumulativeTransform(\n      this.element as HTMLElement,\n    );\n  }\n\n  assertHasInitialBounds(): asserts this is SpriteWithInitialBounds {\n    if (!this._initialBounds) {\n      throw new Error(`sprite does not have initialBounds`);\n    }\n  }\n\n  assertHasOwner(): asserts this is SpriteWithOwner {\n    if (!this.owner) {\n      throw new Error(`sprite does not have owner`);\n    }\n  }\n\n  measureFinalBounds() {\n    if (this._finalBounds) {\n      throw new Error('Sprite already has final bounds');\n    }\n    this._inInitialPosition = false;\n    if (this._offsetSprite) {\n      this._finalBounds = relativeBounds(\n        this.element.getBoundingClientRect() as DOMRect,\n        this._offsetSprite.finalBounds!,\n      );\n    } else {\n      this._finalBounds = this.element.getBoundingClientRect() as DOMRect;\n    }\n    this._finalComputedStyle = copyComputedStyle(this.element);\n    this._finalPosition = this._getCurrentPosition();\n    this._originalFinalBounds = this._finalBounds;\n    this._finalCumulativeTransform = cumulativeTransform(\n      this.element as HTMLElement,\n    );\n  }\n\n  assertHasFinalBounds(): asserts this is SpriteWithFinalBounds {\n    if (!this._finalBounds) {\n      throw new Error(`sprite does not have finalBounds`);\n    }\n  }\n\n  /**\n    Returns the difference between two sprites, represented as x and y\n    coordinates.\n\n    _`this.difference('initialBounds', other, 'finalBounds')` is\n    interpreted as \"the difference between this sprite's initial bounds\n    and the other sprite's final bounds\"._\n\n    _It works this way because each sprite has its own local coordinate\n    system._\n\n    @method difference\n    @param {string} which The current sprite's comparison attribute.\n    @param {Sprite} otherSprite The other sprite.\n    @param {string} otherWhich The other sprite's comparison attribute.\n    @return {Object}\n  */\n  difference(\n    which: 'initialBounds' | 'finalBounds',\n    otherSprite: Sprite,\n    otherWhich: 'initialBounds' | 'finalBounds',\n  ) {\n    let x = this[which]!.left;\n    let y = this[which]!.top;\n    if (this._offsetSprite) {\n      x += this._offsetSprite[which]!.left;\n      y += this._offsetSprite[which]!.top;\n    }\n    if (otherSprite._offsetSprite) {\n      x -= otherSprite._offsetSprite[otherWhich]!.left;\n      y -= otherSprite._offsetSprite[otherWhich]!.top;\n    }\n    return {\n      dx: x - otherSprite[otherWhich]!.left,\n      dy: y - otherSprite[otherWhich]!.top,\n    };\n  }\n\n  set element(value) {\n    this.__element = value;\n  }\n\n  get element() {\n    return this.__element;\n  }\n\n  /**\n    Returns the sprite's current transform, with appropriate caching\n    so that you don't trigger reflows.\n\n    @accessor transform\n    @type {Transform}\n  */\n  get transform() {\n    if (!this._transform) {\n      this._transform = ownTransform(this.element as HTMLElement);\n    }\n    return this._transform;\n  }\n\n  /**\n    This is different from `this.transform` because it's the product\n    of our own transform and all ancestor transforms. It's what you\n    need if you want to understand how many real screen pixels there\n    are to every local pixel in the sprite.\n\n    @accessor cumulativeTransform\n    @type {Object}\n  */\n  get cumulativeTransform() {\n    if (!this._cumulativeTransform) {\n      this._cumulativeTransform = cumulativeTransform(\n        this.element as HTMLElement,\n      );\n    }\n    return this._cumulativeTransform;\n  }\n\n  /**\n    Returns wether the sprite is revealed or not.\n\n    @accessor revealed\n    @type {boolean}\n  */\n  get revealed() {\n    if (this._revealed == null) {\n      this._revealed = !this.__element.classList.contains(\n        'ember-animated-hidden',\n      );\n    }\n    return this._revealed;\n  }\n\n  _rememberSize() {\n    // at the point in time when this runs, we always have either initial or\n    // final measurements, but not both. So this will successfully pick the one\n    // we do have, which applies to what we are currently measuring.\n    let transform = (this.initialCumulativeTransform ||\n      this.finalCumulativeTransform)!;\n    let bounds = (this.initialBounds || this.finalBounds)!;\n\n    this._imposedStyle = {};\n\n    if (isSVG(this.element)) {\n      // we're not doing anything to lock the width & height\n      // SVGElements. it seems rare that we'd need to, since svg\n      // layout tends to be pretty literal.\n      return;\n    }\n\n    // If the user has already provided an inline width or height,\n    // they are taking the wheel and we have to trust them to do\n    // something reasonable.\n    //\n    // I'm not using getComputedStyle here because its width and\n    // height are fairly useless for our purposes (we want \"computed\"\n    // values, but for backward compat with CSS 2.0, getComputedStyle\n    // actually returns the \"used\" values for width and height).\n\n    if ((this.element as HTMLElement).style.width === '') {\n      this._imposedStyle['width'] = `${bounds.width / transform.a}px`;\n      // TODO: do a more sophisticated size measurement so we don't\n      // need to impose border-box. If we're only imposing width OR\n      // height and we weren't originally in border box, we can get an\n      // incorrect change in the non-imposed dimension.\n      this._imposedStyle['box-sizing'] = 'border-box';\n    }\n    if ((this.element as HTMLElement).style.height === '') {\n      this._imposedStyle['height'] = `${bounds.height / transform.d}px`;\n      this._imposedStyle['box-sizing'] = 'border-box';\n    }\n  }\n\n  _lazyOffsets(computedStyle: CSSStyleDeclaration) {\n    let offsets: undefined | { top: number; left: number };\n    return () => {\n      if (!offsets) {\n        offsets = findOffsets(\n          this.element,\n          computedStyle,\n          this.transform,\n          this._offsetSprite!,\n        );\n      }\n      return offsets;\n    };\n  }\n\n  _rememberPosition() {\n    let computedStyle = getComputedStyle(this.element);\n    let style = (this.element as HTMLElement).style;\n    let offsets = this._lazyOffsets(computedStyle);\n    let tx = 0;\n    let ty = 0;\n\n    this._rememberSize();\n\n    if (isSVG(this.element)) {\n      // svg elements are effectively always already absolutely\n      // positioned by their own coordinates.\n      return;\n    }\n\n    if (\n      computedStyle.position !== 'absolute' &&\n      computedStyle.position !== 'fixed'\n    ) {\n      this._imposedStyle!['position'] = 'absolute';\n    }\n\n    if (style.top === '' && style.bottom === '') {\n      // The user had no preexisting inline vertical positioning, so we take over.\n      this._imposedStyle!['top'] = `${offsets().top}px`;\n      this._imposedStyle!['margin-top'] = '0px';\n    } else if (this._imposedStyle!['position']) {\n      // the user has inline styles for controlling vertical position,\n      // but the element was not absolutely positioned, so we apply an\n      // offseting transform.\n      ty = offsets().top - parseFloat(computedStyle.top || '0');\n    }\n\n    if (style.left === '' && style.bottom === '') {\n      // The user had no preexisting inline horizontal positioning, so we take over.\n      this._imposedStyle!['left'] = `${offsets().left}px`;\n      this._imposedStyle!['margin-left'] = `0px`;\n    } else if (this._imposedStyle!['position']) {\n      // the user has inline styles for controlling vertical position,\n      // but the element was not absolutely positioned, so we apply an\n      // offseting transform.\n      tx = offsets().left - parseFloat(computedStyle.left || '0');\n    }\n    if (tx || ty) {\n      this._transform = this.transform.mult(new Transform(1, 0, 0, 1, tx, ty));\n      this._imposedStyle!['transform'] = this.transform.serialize();\n    }\n\n    this._collapsingChildren = collapsedChildren(\n      this.element,\n      computedStyle,\n      'top',\n    );\n  }\n\n  _cacheOriginalStyles() {\n    let cache: Sprite['_styleCache'] = {};\n    let style = (this.element as HTMLElement).style;\n    Object.keys(this._imposedStyle!).forEach((property) => {\n      (cache as any)[property] = (style as any)[property];\n    });\n    this._styleCache = cache;\n  }\n\n  lock() {\n    // In case the user has caused our inline-style-driven position\n    // to drift, we put it back.\n    this._reapplyPosition(this._initialPosition!);\n\n    this.applyStyles(this._imposedStyle!);\n    this._handleMarginCollapse();\n    inFlight.set(this.element, this);\n    this._inInitialPosition = this._lockedToInitialPosition;\n  }\n\n  unlock() {\n    warn(\n      `Probable bug in ember-animated: an interrupted sprite tried to unlock itself.\n       This is usually caused by a direct child of an animated component also being an\n       animated component. To fix it, wrap the child in another DOM element.\n       https://github.com/ember-animation/ember-animated/issues/178`,\n      this.stillInFlight(),\n      { id: 'ember-animated-sprite-unlock' },\n    );\n    inFlight.delete(this.element);\n    let cache = this._styleCache!;\n    Object.keys(cache).forEach((property) => {\n      setStyle(\n        this.element as HTMLElement,\n        property,\n        cache[property] as string,\n      );\n    });\n\n    // In case the user has caused our inline-style-driven position\n    // to drift, we put it back.\n    this._reapplyPosition(this._finalPosition!);\n\n    this._clearMarginCollapse();\n  }\n\n  /**\n    This is your general purpose hook for changing CSS properties of\n    the sprite's element. Use this when there's not a more specific\n    method like `translate()`, `scale()`, `hide()`, or `reveal()`.\n\n    ```js\n    sprite.applyStyles({\n      'opacity': '0',\n      'z-index': '1'\n    });\n    ```\n\n    Nothing you do to the sprite will persist after the transition is\n    finished â€“ we clean things up when it ends.\n\n    @method applyStyles\n    @param {Object} styles The styles to apply to the sprite.\n    @return {void}\n  */\n  applyStyles<T extends { [P in keyof T]: string }>(styles: T) {\n    if (!this._lockMode) {\n      throw new Error(\"can't apply styles to non-lockable sprite\");\n    }\n    if (styles !== this._imposedStyle) {\n      Object.keys(styles).forEach((property) => {\n        if (this._imposedStyle![property] == null) {\n          this._styleCache![property] = (\n            this.element as HTMLElement\n          ).style.getPropertyValue(property);\n        }\n        this._imposedStyle![property] = styles[property as keyof T];\n      });\n    }\n    Object.keys(styles).forEach((property) => {\n      let val = styles[property as keyof T];\n      if (typeof val !== 'string') {\n        throw new Error(\n          `Sprite#applyStyles only accepts string values. Convert any numeric values to strings (with appropriate units) before calling. You passed ${property}=${val}`,\n        );\n      } else {\n        setStyle(\n          this.element as HTMLElement,\n          property,\n          styles[property as keyof T],\n        );\n      }\n    });\n  }\n\n  stillInFlight() {\n    return inFlight.get(this.element) === this;\n  }\n\n  /**\n    Hides the sprite using CSS visibility property.\n\n    @method hide\n    @return {void}\n  */\n  hide() {\n    this._revealed = false;\n    this.__element.classList.add('ember-animated-hidden');\n  }\n\n  /**\n    Reveals the sprite using CSS visibility property.\n\n    _Newly inserted sprites start hidden, and are revealed when you\n    start animating them. You can manually reveal them with this if\n    you want them to appear right away and you're not animating them._\n\n    @method reveal\n    @return {void}\n  */\n  reveal() {\n    if (!this.revealed) {\n      this._revealed = true;\n      this.__element.classList.remove('ember-animated-hidden');\n    }\n  }\n\n  /**\n    Manages the application of the `ember-animated-none` CSS class on\n    the element.\n\n    When the flag is truthy, the class is removed and the element is\n    therefore visible.\n\n    When the flag is falsy, the class is applied and the element is\n    therefore hidden.\n\n    @method display\n    @param {boolean} flag\n    @return {void}\n  */\n  display(flag: boolean) {\n    if (flag) {\n      this.__element.classList.remove('ember-animated-none');\n    } else {\n      this.__element.classList.add('ember-animated-none');\n    }\n  }\n\n  /**\n    Translates the sprite by the given number of screen pixels.\n\n    _Disregards any pre-existing transforms._\n\n    @method translate\n    @param {number} dx The number of screen pixels on the x axis.\n    @param {number} dy The number of screen pixels on the y axis.\n    @return {void}\n  */\n  translate(dx: number, dy: number) {\n    let t = this.transform;\n    t = t.mult(new Transform(1, 0, 0, 1, dx / t.a, dy / t.d));\n    this._transform = t;\n    this.applyStyles({\n      transform: t.serialize(),\n      'transform-origin': '0 0',\n    });\n  }\n\n  /**\n    Adjusts the sprite's scale by the given scaling factors.\n\n    @method scale\n    @param {number} scaleX The scaling factor to apply to the x axis.\n    @param {number} scaleY The scaling factor to apply to the y axis.\n    @return {void}\n  */\n  scale(scaleX: number, scaleY: number) {\n    let t = this.transform.mult(new Transform(scaleX, 0, 0, scaleY, 0, 0));\n    this._transform = t;\n    this.applyStyles({\n      transform: t.serialize(),\n      'transform-origin': '0 0',\n    });\n  }\n\n  /**\n    Adjusts the sprite so it will still be in the same visual position\n    despite being moved into a new offset parent.\n\n    @method rehome\n    @param {Sprite} newOffsetSprite\n    @return {void}\n  */\n  rehome(newOffsetSprite: Sprite) {\n    let screenBounds = this.absoluteInitialBounds;\n    let newRelativeBounds = shiftedBounds(\n      screenBounds,\n      -newOffsetSprite.initialBounds!.left,\n      -newOffsetSprite.initialBounds!.top,\n    );\n\n    let initialAmbientTransform = this._offsetSprite!.cumulativeTransform;\n    let finalAmbientTransform = newOffsetSprite.cumulativeTransform;\n\n    let t = this.transform;\n    t = t.mult(\n      new Transform(\n        initialAmbientTransform.a / finalAmbientTransform.a,\n        0,\n        0,\n        initialAmbientTransform.d / finalAmbientTransform.d,\n        (newRelativeBounds.left - t.tx) / t.a,\n        (newRelativeBounds.top - t.ty) / t.d,\n      ),\n    );\n    this._transform = t;\n    this._imposedStyle!['transform'] = t.serialize();\n    this._imposedStyle!['transform-origin'] = '0 0';\n    this._imposedStyle!['top'] = `0px`;\n    this._imposedStyle!['left'] = `0px`;\n    this._offsetSprite = newOffsetSprite;\n    this._initialBounds = newRelativeBounds;\n    this._inInitialPosition = true;\n  }\n\n  _handleMarginCollapse() {\n    if (this._collapsingChildren) {\n      const children = this._collapsingChildren;\n      for (const child of children) {\n        child.classList.add('ember-animated-top-collapse');\n      }\n    }\n  }\n  _clearMarginCollapse() {\n    if (this._collapsingChildren) {\n      const children = this._collapsingChildren;\n      for (const child of children) {\n        child.classList.remove('ember-animated-top-collapse');\n      }\n    }\n  }\n\n  /**\n    Sets the sprite's `initialBounds` relative to the provided `otherSprite`.\n\n    @method startAtSprite\n    @param {Sprite} otherSprite\n    @return {void}\n  */\n  startAtSprite(otherSprite: Sprite) {\n    continueMotions(otherSprite.element, this.element);\n    let diff = this.difference('finalBounds', otherSprite, 'initialBounds');\n    this.startTranslatedBy(-diff.dx, -diff.dy);\n    this._initialBounds = resizedBounds(\n      this._initialBounds!,\n      otherSprite.initialBounds!.width,\n      otherSprite.initialBounds!.height,\n    );\n    this._initialComputedStyle = otherSprite.initialComputedStyle;\n    this._initialCumulativeTransform = otherSprite.initialCumulativeTransform;\n  }\n\n  /**\n    Sets the sprite's `initialBounds` using the provided\n    x and y coordinates.\n\n    ```js\n    sprite.startAtPixel({ x: 0, y: 0 });\n    ```\n\n    @method startAtPixel\n    @param {Object} point The x and y coordinates.\n    @return {void}\n  */\n  startAtPixel({ x, y }: { x?: number; y?: number }) {\n    let dx = 0;\n    let dy = 0;\n    if (x != null) {\n      dx = x - this._finalBounds!.left;\n      if (this._offsetSprite) {\n        dx -= this._offsetSprite.finalBounds!.left;\n      }\n    }\n    if (y != null) {\n      dy = y - this._finalBounds!.top;\n      if (this._offsetSprite) {\n        dy -= this._offsetSprite.finalBounds!.top;\n      }\n    }\n    this.startTranslatedBy(dx, dy);\n  }\n\n  /**\n    Sets the sprite's `initialBounds` relative to its `finalBounds`.\n\n    @method startTranslatedBy\n    @param {number} dx\n    @param {number} dy\n    @return {void}\n  */\n  startTranslatedBy(dx: number, dy: number) {\n    let priorInitialBounds = this._initialBounds!;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (this._offsetSprite) {\n      offsetX =\n        this._offsetSprite.finalBounds!.left -\n        this._offsetSprite.initialBounds!.left;\n      offsetY =\n        this._offsetSprite.finalBounds!.top -\n        this._offsetSprite.initialBounds!.top;\n    }\n    this._initialBounds = shiftedBounds(\n      this._finalBounds!,\n      dx - offsetX,\n      dy - offsetY,\n    );\n\n    if (this._inInitialPosition) {\n      // we were already moved into our priorInitiaBounds position, so we need to compensate\n      this.translate(\n        this._initialBounds.left - priorInitialBounds.left,\n        this._initialBounds.top - priorInitialBounds.top,\n      );\n    } else {\n      this.translate(\n        this._initialBounds.left - this._finalBounds!.left,\n        this._initialBounds.top - this._finalBounds!.top,\n      );\n      this._inInitialPosition = true;\n    }\n  }\n\n  /**\n    Moves the sprite to its final position (`finalBounds`).\n\n    @method moveToFinalPosition\n    @return {void}\n  */\n  moveToFinalPosition() {\n    if (this._inInitialPosition) {\n      let initial = this._initialBounds!;\n      let final = this._finalBounds!;\n      let dx = final.left - initial.left;\n      let dy = final.top - initial.top;\n      this.translate(dx, dy);\n      this._inInitialPosition = false;\n    }\n  }\n\n  /**\n    Sets the sprite's `finalBounds` using the provided `otherSprite`.\n\n    @method endAtSprite\n    @param {Sprite} otherSprite\n    @return {void}\n  */\n  endAtSprite(otherSprite: Sprite) {\n    let diff = otherSprite.difference('finalBounds', this, 'initialBounds');\n    this.endTranslatedBy(diff.dx, diff.dy);\n    this._finalBounds = resizedBounds(\n      this._finalBounds!,\n      otherSprite.finalBounds!.width,\n      otherSprite.finalBounds!.height,\n    );\n    this._finalComputedStyle = otherSprite.finalComputedStyle;\n    this._finalCumulativeTransform = otherSprite.finalCumulativeTransform;\n  }\n\n  /**\n    Sets the sprite's `finalBounds` using the provided point `{ x, y }`.\n\n    ```js\n    sprite.endAtPixel({ x: window.innerWidth });\n    ```\n\n    @method endAtPixel\n    @param {Object} point The x and y coordinates.\n    @return {void}\n  */\n  endAtPixel({ x, y }: { x?: number; y?: number }) {\n    let dx = 0;\n    let dy = 0;\n    if (x != null) {\n      dx = x - this._initialBounds!.left;\n      if (this._offsetSprite) {\n        dx -= this._offsetSprite.initialBounds!.left;\n      }\n    }\n    if (y != null) {\n      dy = y - this._initialBounds!.top;\n      if (this._offsetSprite) {\n        dy -= this._offsetSprite.initialBounds!.top;\n      }\n    }\n    this.endTranslatedBy(dx, dy);\n  }\n\n  /**\n    Sets the sprite's `finalBounds` using its `initialBounds` and\n    the provided x and y axis offset.\n\n    @method endTranslatedBy\n    @param {number} dx The x axis offset.\n    @param {number} dy The y axis offset.\n    @return {void}\n  */\n  endTranslatedBy(dx: number, dy: number) {\n    this._finalBounds = shiftedBounds(this._initialBounds!, dx, dy);\n  }\n\n  /**\n    Sets this sprite's `finalBounds` so that its position relative\n    to the `otherSprite` remains constant through the transition.\n\n    @method endRelativeTo\n    @param {Sprite} otherSprite Note: must have initial and final bounds\n    @return {void}\n  */\n  endRelativeTo(otherSprite: Sprite) {\n    this.endTranslatedBy(\n      otherSprite.finalBounds!.left - otherSprite.initialBounds!.left,\n      otherSprite.finalBounds!.top - otherSprite.initialBounds!.top,\n    );\n  }\n}\n\nfunction findOffsets(\n  element: Element,\n  computedStyle: CSSStyleDeclaration,\n  transform: Transform,\n  offsetSprite: Sprite,\n) {\n  let ownBounds = element.getBoundingClientRect();\n  let left = ownBounds.left;\n  let top = ownBounds.top;\n  let effectiveOffsetParent;\n\n  if (computedStyle.position !== 'fixed') {\n    effectiveOffsetParent = offsetSprite.element;\n  }\n\n  if (effectiveOffsetParent) {\n    if (effectiveOffsetParent.tagName === 'BODY') {\n      // reading scroll off body doesn't reliably work cross browser\n      left += window.scrollX;\n      top += window.scrollY;\n    } else {\n      left += effectiveOffsetParent.scrollLeft;\n      top += effectiveOffsetParent.scrollTop;\n    }\n\n    let eopComputedStyle = getComputedStyle(effectiveOffsetParent);\n    if (\n      eopComputedStyle.position !== 'static' ||\n      eopComputedStyle.transform !== 'none'\n    ) {\n      let eopBounds = effectiveOffsetParent.getBoundingClientRect();\n      left -=\n        eopBounds.left + parseFloat(eopComputedStyle.borderLeftWidth || '0');\n      top -= eopBounds.top + parseFloat(eopComputedStyle.borderTopWidth || '0');\n\n      let eopTransform = cumulativeTransform(\n        effectiveOffsetParent as HTMLElement,\n      );\n      left /= eopTransform.a;\n      top /= eopTransform.d;\n    }\n  }\n\n  left -= transform.tx;\n  top -= transform.ty;\n\n  return { top, left };\n}\n\nconst SVGNamespace = 'http://www.w3.org/2000/svg';\n\n// We have special handling for SVG elements inside SVG documents. An\n// <svg> tag itself whose parent is not SVG doesn't need special\n// handling -- it participates in normal HTML positioning.\nfunction isSVG(element: Element): element is SVGElement {\n  return (\n    element.namespaceURI === SVGNamespace &&\n    (element.parentElement || false) &&\n    element.parentElement.namespaceURI === SVGNamespace\n  );\n}\n\n// This distinguishes HTML vs SVG rules, and for HTML it compensates\n// for the fact that browsers are inconsistent in the way they report\n// offsetLeft & offsetTop for elements with a transformed ancestor\n// beneath their nearest positioned ancestor.\nfunction getEffectiveOffsetParent(element: HTMLElement) {\n  if (isSVG(element)) {\n    let cursor = element.parentElement;\n    while (cursor && cursor.namespaceURI === SVGNamespace) {\n      if (cursor.tagName === 'svg') {\n        return cursor;\n      }\n      cursor = cursor.parentElement;\n    }\n    // we should never fall through here -- presumably we must find an\n    // <svg> tag somewhere before we exit the svg namespace. But if we\n    // do fall through, I'll just let this continue into the regular\n    // HTML rules below.\n  }\n\n  let offsetParent = element.offsetParent;\n  let cursor = element.parentElement;\n  while (cursor && offsetParent && cursor !== offsetParent) {\n    let styles = window.getComputedStyle(cursor);\n    let t = styles.transform !== '' ? styles.transform : cursor.style.transform;\n    if (t !== 'none') {\n      return cursor;\n    }\n    cursor = cursor.parentElement;\n  }\n  return offsetParent;\n}\n\nfunction getSVGLength(element: SVGElement, property: string): number | null {\n  if ((element as any)[property]) {\n    return (element as any)[property].baseVal.value;\n  }\n  return null;\n}\n\nfunction setSVGLength(element: SVGElement, property: string, values: any) {\n  if (typeof (values as any)[property] === 'number') {\n    (element as any)[property].baseVal.value = (values as any)[property];\n  }\n}\n\nfunction setAttribute(element: Element, attrName: string, values: any) {\n  let value = values[attrName];\n  if (value) {\n    element.setAttribute(attrName as string, value);\n  } else {\n    element.removeAttribute(attrName as string);\n  }\n}\n\nfunction setStyle(element: HTMLElement, property: string, value: string) {\n  if (/[A-Z]/.test(property)) {\n    throw new Error(\n      `applyStyles expects all CSS property names to be formatted as in CSS. Not camelcased. You passed ${property}.`,\n    );\n  }\n  element.style.setProperty(property, value);\n}\n\n// getComputedStyle returns a *live* CSSStyleDeclaration that will\n// keep changing as the element changes. So we use this to copy off a\n// snapshot of the properties we potentially care about.\nfunction copyComputedStyle(element: Element): CopiedCSS {\n  let computed = getComputedStyle(element);\n  let output = new CopiedCSS();\n  for (let property of COPIED_CSS_PROPERTIES) {\n    output[property as keyof CopiedCSS] = computed.getPropertyValue(property);\n  }\n  return output;\n}\n\nexport class CopiedCSS {\n  'opacity': string;\n  'font-size': string;\n  'font-family': string;\n  'font-weight': string;\n  'color': string;\n  'background-color': string;\n  'border-color': string;\n  'letter-spacing': string;\n  'line-height': string;\n  'text-align': string;\n  'text-transform': string;\n  'padding': string;\n  'padding-top': string;\n  'padding-bottom': string;\n  'padding-left': string;\n  'padding-right': string;\n  'border-radius': string;\n  'border-top-left-radius': string;\n  'border-top-right-radius': string;\n  'border-bottom-left-radius': string;\n  'border-bottom-right-radius': string;\n  'box-shadow': string;\n}\n\nconst COPIED_CSS_PROPERTIES = [\n  'opacity',\n  'font-size',\n  'font-family',\n  'font-weight',\n  'color',\n  'background-color',\n  'border-color',\n  'letter-spacing',\n  'line-height',\n  'text-align',\n  'text-transform',\n  'padding',\n  'padding-top',\n  'padding-bottom',\n  'padding-left',\n  'padding-right',\n  'border-radius',\n  'border-top-left-radius',\n  'border-top-right-radius',\n  'border-bottom-left-radius',\n  'border-bottom-right-radius',\n  'box-shadow',\n];\n\nexport interface SVGPosition {\n  x: number | null;\n  y: number | null;\n  cx: number | null;\n  cy: number | null;\n  r: number | null;\n  width: number | null;\n  height: number | null;\n  transform: string | null;\n}\n\ninterface HTMLPosition {\n  top: string | null;\n  left: string | null;\n  bottom: string | null;\n  right: string | null;\n  transform: string;\n  classList: string[];\n}\n\n// This strange construct allows access of the alternative type's keys returning undefined values.\n// This significantly simplifies our typing efforts.\nexport type SpritePosition =\n  | (HTMLPosition &\n      Partial<\n        Record<Exclude<keyof SVGPosition, keyof HTMLPosition>, undefined>\n      >)\n  | (SVGPosition &\n      Partial<\n        Record<Exclude<keyof HTMLPosition, keyof SVGPosition>, undefined>\n      >);\n\nexport interface SpriteWithInitialBounds extends Sprite {\n  initialBounds: DOMRect;\n  initialComputedStyle: CopiedCSS;\n  initialPosition: DOMRect;\n  originalInitialBounds: DOMRect;\n  initialCumulativeTransform: Transform;\n}\n\nexport interface SpriteWithFinalBounds extends Sprite {\n  finalBounds: DOMRect;\n  finalComputedStyle: CopiedCSS;\n  finalPosition: DOMRect;\n  originalFinalBounds: DOMRect;\n  finalCumulativeTransform: Transform;\n}\n\nexport interface SpriteWithOwner extends Sprite {\n  owner: Child;\n}\n"],"names":["inFlight","getOrCreate","WeakMap","Sprite","offsetParentStartingAt","element","parent","getEffectiveOffsetParent","document","getElementsByTagName","offsetParentEndingAt","positionedStartingAt","offsetSprite","initialBounds","Error","positionedEndingAt","finalBounds","sizedStartingAt","sizedEndingAt","sprite","_initialBounds","emptyBounds","_initialComputedStyle","_finalComputedStyle","_initialPosition","_finalPosition","_originalInitialBounds","_initialCumulativeTransform","_finalCumulativeTransform","constructor","inInitialPosition","lockMode","_defineProperty","_offsetSprite","_lockedToInitialPosition","measureInitialBounds","measureFinalBounds","predecessor","get","_styleCache","_revealed","_imposedStyle","_collapsingChildren","_lockMode","_rememberPosition","_cacheOriginalStyles","_rememberSize","Ember","testing","Object","seal","absoluteInitialBounds","shiftedBounds","left","top","_finalBounds","absoluteFinalBounds","initialComputedStyle","finalComputedStyle","getInitialDimension","name","getFinalDimension","initialCumulativeTransform","finalCumulativeTransform","originalInitialBounds","originalFinalBounds","_originalFinalBounds","getCurrentBounds","relativeBounds","getBoundingClientRect","_getCurrentPosition","isSVG","position","x","getSVGLength","y","cx","cy","r","width","height","transform","getAttribute","style","bottom","right","classList","Array","from","_reapplyPosition","pos","setSVGLength","setAttribute","p","cls","add","includes","remove","_inInitialPosition","copyComputedStyle","cumulativeTransform","assertHasInitialBounds","assertHasOwner","owner","assertHasFinalBounds","difference","which","otherSprite","otherWhich","dx","dy","value","__element","_transform","ownTransform","_cumulativeTransform","revealed","contains","bounds","a","d","_lazyOffsets","computedStyle","offsets","findOffsets","getComputedStyle","tx","ty","parseFloat","mult","Transform","serialize","collapsedChildren","cache","keys","forEach","property","lock","applyStyles","_handleMarginCollapse","set","unlock","warn","stillInFlight","id","delete","setStyle","_clearMarginCollapse","styles","getPropertyValue","val","hide","reveal","display","flag","translate","t","scale","scaleX","scaleY","rehome","newOffsetSprite","screenBounds","newRelativeBounds","initialAmbientTransform","finalAmbientTransform","children","child","startAtSprite","continueMotions","diff","startTranslatedBy","resizedBounds","startAtPixel","priorInitialBounds","offsetX","offsetY","moveToFinalPosition","initial","final","endAtSprite","endTranslatedBy","endAtPixel","endRelativeTo","ownBounds","effectiveOffsetParent","tagName","window","scrollX","scrollY","scrollLeft","scrollTop","eopComputedStyle","eopBounds","borderLeftWidth","borderTopWidth","eopTransform","SVGNamespace","namespaceURI","parentElement","cursor","offsetParent","baseVal","values","attrName","removeAttribute","test","setProperty","computed","output","CopiedCSS","COPIED_CSS_PROPERTIES"],"mappings":"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"}