{"version":3,"file":"scheduler.js","sources":["../../src/-private/scheduler.ts"],"sourcesContent":["/*\n\nAPI\n===\n\n  spawn: GenFn -> CancelablePromise\n\n    starts a new microroutine, which will run independently until it\n    finishes or is canceled.\n\n  spawnChild: GenFn -> CancelablePromise\n\n    starts a new microroutine linked to the current\n    microroutine. Throws if you're not in a current\n    microroutine.\n\n    \"Linked\" means that if the caller is canceled, the new\n    microroutine is also canceled. The inverse is not true: if the new\n    microroutine is canceled, the caller is not canceled.\n\n    `cancel(caller)` causes children to be canceled regardless of what\n    state caller is in. For example, even if caller has finished, any\n    children that haven't already finished will still be canceled.\n\n  stop: CancelablePromise -> null\n\n    cancel the microroutine represented by this promise.\n\n  current: () -> CancelablePromise\n\n    return the promise representing the currently executing\n    microroutine, or null if there is none. This exists because\n    spawning happens synchronously, meaning it begins running before\n    spawn returns, meaning there's no other way to get an early handle\n    on yourself.\n\n\n*/\n\nimport {\n  registerCancellation,\n  fireCancellation,\n} from './concurrency-helpers.ts';\nimport { getOrCreate as _getOrCreate } from './singleton.ts';\n\nfunction getOrCreate<T>(key: string, construct: () => T): T {\n  return _getOrCreate(`scheduler.${key}`, construct);\n}\n\n// TODO: specialize the Generator types here so you can only yield promises and\n// get back the promise's resolved type.\nexport function spawn(genFn: () => Generator) {\n  let m = new MicroRoutine(genFn, false);\n  return m.promise;\n}\n\nexport function spawnChild(genFn: () => Generator) {\n  let m = new MicroRoutine(genFn, true);\n  return m.promise;\n}\n\nexport function stop(microRoutinePromise: Promise<any>) {\n  if (microRoutinePromise === current()) {\n    let e = new Error('TaskCancelation');\n    e.message = 'TaskCancelation';\n    throw e;\n  }\n  let microRoutine = microRoutines.get(microRoutinePromise);\n  if (microRoutine) {\n    microRoutine.stop();\n  }\n}\n\nexport function logErrors(fn: (err: Error) => void) {\n  ensureCurrent('logErrors').errorLogger = fn;\n}\n\nexport function current() {\n  let cur = getCurrent();\n  if (cur) {\n    return cur.promise;\n  }\n  return;\n}\n\nexport async function childrenSettled() {\n  return Promise.all(\n    ensureCurrent('childrenSettled').linked.map((child) =>\n      child.promise.catch(() => null),\n    ),\n  );\n}\n\ninterface TaskCancelationError extends Error {\n  message: string;\n}\n\nfunction isTaskCancelationError(x: unknown) {\n  return (x as TaskCancelationError).message === 'TaskCancelation';\n}\n\ninterface StackEntry {\n  microroutine: MicroRoutine | undefined;\n  throw: Error | undefined;\n}\nlet withCurrent: (routine: MicroRoutine, fn: () => void) => void;\nlet getCurrent: () => MicroRoutine | undefined;\nlet onStack: (routine: MicroRoutine) => StackEntry | undefined;\n{\n  interface routinesState {\n    cur: MicroRoutine | undefined;\n    prior: StackEntry[];\n  }\n\n  const routines = getOrCreate(\n    'routines',\n    () =>\n      ({\n        cur: undefined,\n        prior: [],\n      }) as routinesState,\n  );\n\n  // let cur: MicroRoutine | undefined;\n  // let prior: StackEntry[] = [];\n  withCurrent = function (routine, fn) {\n    routines.prior.unshift({ microroutine: routines.cur, throw: undefined });\n    routines.cur = routine;\n    try {\n      return fn();\n    } finally {\n      let restore = routines.prior.shift()!;\n      routines.cur = restore.microroutine;\n      if (restore.throw) {\n        /*\n           Why is this not really \"unsafe\"? Because if the\n           microroutine that we are restoring has been cancelled, the\n           cancellation takes precedence over any exception that it\n           was going to see, so it's OK that this throw will silently\n           stomp a throw coming out of the above block.\n        */\n        throw restore.throw; // eslint-disable-line no-unsafe-finally\n      }\n    }\n  };\n  getCurrent = function () {\n    return routines.cur;\n  };\n  onStack = function (microroutine) {\n    return routines.prior.find((entry) => entry.microroutine === microroutine);\n  };\n}\n\nfunction ensureCurrent(label: string) {\n  let cur = getCurrent();\n  if (!cur) {\n    throw new Error(`${label}: only works inside a running microroutine`);\n  }\n  return cur;\n}\n\nlet loggedErrors = getOrCreate<WeakSet<Error>>(\n  'loggedErrors',\n  () => new WeakSet(),\n);\nlet microRoutines = getOrCreate<WeakMap<Promise<any>, MicroRoutine>>(\n  'microRoutines',\n  () => new WeakMap(),\n);\n\nclass MicroRoutine {\n  private generator: Generator;\n  private resolve!: (value?: any) => void;\n  private reject!: (reason?: any) => void;\n  private stopped = false;\n  private state!: IteratorResult<any>;\n\n  linked: MicroRoutine[] = [];\n  errorLogger: ((e: Error) => void) | undefined;\n  promise: Promise<any>;\n\n  constructor(genFn: () => Generator, linkToParent: boolean) {\n    this.generator = genFn();\n    this.promise = new Promise((res, rej) => {\n      this.resolve = res;\n      this.reject = rej;\n    });\n    microRoutines.set(this.promise, this);\n    registerCancellation(this.promise, this.stop.bind(this));\n\n    if (linkToParent) {\n      let parent = ensureCurrent('spawnChild');\n      parent.linked.push(this);\n      this.errorLogger = parent.errorLogger;\n    }\n    this.wake('fulfilled', undefined);\n  }\n  wake(state: 'fulfilled' | 'rejected', value: any) {\n    if (this.stopped) {\n      return;\n    }\n    withCurrent(this, () => {\n      try {\n        if (state === 'fulfilled') {\n          this.state = this.generator.next(value);\n        } else {\n          // All native generators have a throw, Typescript doesn't seem to know\n          // that because it defines Generator as just an Iterator.\n          this.state = this.generator.throw!(value);\n        }\n        if (this.state.done) {\n          this.resolve(this.state.value);\n        } else {\n          Promise.resolve(this.state.value).then(\n            (value) => this.wake('fulfilled', value),\n            (reason) => this.wake('rejected', reason),\n          );\n        }\n      } catch (err) {\n        this.state = {\n          done: true,\n          value: undefined,\n        };\n        this.linked.forEach((microRoutine) => {\n          microRoutine.stop();\n        });\n        if (!isTaskCancelationError(err)) {\n          this.reject(err);\n          if (this.errorLogger) {\n            if (!loggedErrors.has(err as TaskCancelationError)) {\n              loggedErrors.add(err as TaskCancelationError);\n              this.errorLogger.call(null, err as TaskCancelationError);\n            }\n          }\n        }\n      }\n    });\n  }\n  stop() {\n    this.stopped = true;\n    if (this.state && isPromise(this.state.value)) {\n      fireCancellation(this.state.value);\n    }\n    this.linked.forEach((microRoutine) => {\n      microRoutine.stop();\n    });\n    let e = new Error('TaskCancelation');\n    e.message = 'TaskCancelation';\n    if (getCurrent() === this) {\n      // when a microroutine calls stop() resulting it stopping\n      // itself, the stop call throws TaskCancellation to unwind its\n      // own stack.\n      throw e;\n    }\n    let s = onStack(this);\n    if (s) {\n      // because of the synchronous nature of spawn() and stop(), it's\n      // possible that the microroutine we're stopping is already on\n      // the current call stack above us. If we tried to\n      // cancelGenerator it would give a \"generator already running\"\n      // exception. Instead we save the exception to throw when\n      // control returns back to the stopped microroutine.\n      s.throw = e;\n    } else {\n      // the stopped microroutine is not on our call stack, so we can\n      // throw an exception into it to unwind the generator's stack.\n      withCurrent(this, () => cancelGenerator(this.generator));\n    }\n  }\n}\n\nfunction cancelGenerator(generator: Generator) {\n  let e = new Error('TaskCancelation');\n  e.message = 'TaskCancelation';\n  try {\n    generator.throw!(e);\n  } catch (err) {\n    if (!isTaskCancelationError(err)) {\n      throw err;\n    }\n  }\n}\n\nfunction isPromise(thing: any): thing is Promise<any> {\n  return thing && typeof thing.then === 'function';\n}\n\n// composes several promise-returning functions into a single\n// promise-returning function that executes all in parallel.\n//\n// This allows point-free style, like:\n//   sprites.forEach(parallel(move, scale)).\n//\nexport function parallel(...functions: ((...args: any[]) => unknown)[]) {\n  return function (...args: any[]) {\n    // eslint-disable-next-line prefer-spread\n    return Promise.all(functions.map((f) => f.apply(null, args)));\n  };\n}\n\n// composes several promise-returning functions into a single\n// promise-returning function that executes all in series.\n//\n// This allows point-free style, like:\n//   sprites.forEach(serial(scale, move)).\n//\nexport function serial(...functions: ((...args: any[]) => unknown)[]) {\n  return function (...args: any[]) {\n    return spawnChild(function* () {\n      for (let fn of functions) {\n        // eslint-disable-next-line prefer-spread\n        yield fn.apply(null, args);\n      }\n    });\n  };\n}\n"],"names":["getOrCreate","key","construct","_getOrCreate","spawn","genFn","m","MicroRoutine","promise","spawnChild","stop","microRoutinePromise","current","e","Error","message","microRoutine","microRoutines","get","logErrors","fn","ensureCurrent","errorLogger","cur","getCurrent","childrenSettled","Promise","all","linked","map","child","catch","isTaskCancelationError","x","withCurrent","onStack","routines","undefined","prior","routine","unshift","microroutine","throw","restore","shift","find","entry","label","loggedErrors","WeakSet","WeakMap","generator","resolve","reject","stopped","state","constructor","linkToParent","res","rej","set","registerCancellation","bind","parent","push","wake","value","next","done","then","reason","err","forEach","has","add","call","isPromise","fireCancellation","s","cancelGenerator","thing","parallel","functions","args","f","apply","serial"],"mappings":";;;AAAA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAQA,SAASA,WAAWA,CAAIC,GAAW,EAAEC,SAAkB,EAAK;AAC1D,EAAA,OAAOC,aAAY,CAAC,CAAA,UAAA,EAAaF,GAAG,CAAE,CAAA,EAAEC,SAAS,CAAC;AACpD;;AAEA;AACA;AACO,SAASE,KAAKA,CAACC,KAAsB,EAAE;EAC5C,IAAIC,CAAC,GAAG,IAAIC,YAAY,CAACF,KAAK,EAAE,KAAK,CAAC;EACtC,OAAOC,CAAC,CAACE,OAAO;AAClB;AAEO,SAASC,UAAUA,CAACJ,KAAsB,EAAE;EACjD,IAAIC,CAAC,GAAG,IAAIC,YAAY,CAACF,KAAK,EAAE,IAAI,CAAC;EACrC,OAAOC,CAAC,CAACE,OAAO;AAClB;AAEO,SAASE,IAAIA,CAACC,mBAAiC,EAAE;AACtD,EAAA,IAAIA,mBAAmB,KAAKC,OAAO,EAAE,EAAE;AACrC,IAAA,IAAIC,CAAC,GAAG,IAAIC,KAAK,CAAC,iBAAiB,CAAC;IACpCD,CAAC,CAACE,OAAO,GAAG,iBAAiB;AAC7B,IAAA,MAAMF,CAAC;AACT;AACA,EAAA,IAAIG,YAAY,GAAGC,aAAa,CAACC,GAAG,CAACP,mBAAmB,CAAC;AACzD,EAAA,IAAIK,YAAY,EAAE;IAChBA,YAAY,CAACN,IAAI,EAAE;AACrB;AACF;AAEO,SAASS,SAASA,CAACC,EAAwB,EAAE;AAClDC,EAAAA,aAAa,CAAC,WAAW,CAAC,CAACC,WAAW,GAAGF,EAAE;AAC7C;AAEO,SAASR,OAAOA,GAAG;AACxB,EAAA,IAAIW,GAAG,GAAGC,UAAU,EAAE;AACtB,EAAA,IAAID,GAAG,EAAE;IACP,OAAOA,GAAG,CAACf,OAAO;AACpB;AACA,EAAA;AACF;AAEO,eAAeiB,eAAeA,GAAG;EACtC,OAAOC,OAAO,CAACC,GAAG,CAChBN,aAAa,CAAC,iBAAiB,CAAC,CAACO,MAAM,CAACC,GAAG,CAAEC,KAAK,IAChDA,KAAK,CAACtB,OAAO,CAACuB,KAAK,CAAC,MAAM,IAAI,CAChC,CACF,CAAC;AACH;AAMA,SAASC,sBAAsBA,CAACC,CAAU,EAAE;AAC1C,EAAA,OAAQA,CAAC,CAA0BlB,OAAO,KAAK,iBAAiB;AAClE;AAMA,IAAImB,WAA4D;AAChE,IAAIV,UAA0C;AAC9C,IAAIW,OAA0D;AAC9D;AAME,EAAA,MAAMC,QAAQ,GAAGpC,WAAW,CAC1B,UAAU,EACV,OACG;AACCuB,IAAAA,GAAG,EAAEc,SAAS;AACdC,IAAAA,KAAK,EAAE;AACT,GAAC,CACL,CAAC;;AAED;AACA;AACAJ,EAAAA,WAAW,GAAG,UAAUK,OAAO,EAAEnB,EAAE,EAAE;AACnCgB,IAAAA,QAAQ,CAACE,KAAK,CAACE,OAAO,CAAC;MAAEC,YAAY,EAAEL,QAAQ,CAACb,GAAG;AAAEmB,MAAAA,KAAK,EAAEL;AAAU,KAAC,CAAC;IACxED,QAAQ,CAACb,GAAG,GAAGgB,OAAO;IACtB,IAAI;MACF,OAAOnB,EAAE,EAAE;AACb,KAAC,SAAS;MACR,IAAIuB,OAAO,GAAGP,QAAQ,CAACE,KAAK,CAACM,KAAK,EAAG;AACrCR,MAAAA,QAAQ,CAACb,GAAG,GAAGoB,OAAO,CAACF,YAAY;MACnC,IAAIE,OAAO,CAACD,KAAK,EAAE;AACjB;AACR;AACA;AACA;AACA;AACA;AACA;AACQ,QAAA,MAAMC,OAAO,CAACD,KAAK,CAAC;AACtB;AACF;GACD;EACDlB,UAAU,GAAG,YAAY;IACvB,OAAOY,QAAQ,CAACb,GAAG;GACpB;AACDY,EAAAA,OAAO,GAAG,UAAUM,YAAY,EAAE;AAChC,IAAA,OAAOL,QAAQ,CAACE,KAAK,CAACO,IAAI,CAAEC,KAAK,IAAKA,KAAK,CAACL,YAAY,KAAKA,YAAY,CAAC;GAC3E;AACH;AAEA,SAASpB,aAAaA,CAAC0B,KAAa,EAAE;AACpC,EAAA,IAAIxB,GAAG,GAAGC,UAAU,EAAE;EACtB,IAAI,CAACD,GAAG,EAAE;AACR,IAAA,MAAM,IAAIT,KAAK,CAAC,CAAGiC,EAAAA,KAAK,4CAA4C,CAAC;AACvE;AACA,EAAA,OAAOxB,GAAG;AACZ;AAEA,IAAIyB,YAAY,GAAGhD,WAAW,CAC5B,cAAc,EACd,MAAM,IAAIiD,OAAO,EACnB,CAAC;AACD,IAAIhC,aAAa,GAAGjB,WAAW,CAC7B,eAAe,EACf,MAAM,IAAIkD,OAAO,EACnB,CAAC;AAED,MAAM3C,YAAY,CAAC;EACT4C,SAAS;EACTC,OAAO;EACPC,MAAM;AACNC,EAAAA,OAAO,GAAG,KAAK;EACfC,KAAK;AAEb3B,EAAAA,MAAM,GAAmB,EAAE;EAC3BN,WAAW;EACXd,OAAO;AAEPgD,EAAAA,WAAWA,CAACnD,KAAsB,EAAEoD,YAAqB,EAAE;AACzD,IAAA,IAAI,CAACN,SAAS,GAAG9C,KAAK,EAAE;IACxB,IAAI,CAACG,OAAO,GAAG,IAAIkB,OAAO,CAAC,CAACgC,GAAG,EAAEC,GAAG,KAAK;MACvC,IAAI,CAACP,OAAO,GAAGM,GAAG;MAClB,IAAI,CAACL,MAAM,GAAGM,GAAG;AACnB,KAAC,CAAC;IACF1C,aAAa,CAAC2C,GAAG,CAAC,IAAI,CAACpD,OAAO,EAAE,IAAI,CAAC;AACrCqD,IAAAA,oBAAoB,CAAC,IAAI,CAACrD,OAAO,EAAE,IAAI,CAACE,IAAI,CAACoD,IAAI,CAAC,IAAI,CAAC,CAAC;AAExD,IAAA,IAAIL,YAAY,EAAE;AAChB,MAAA,IAAIM,MAAM,GAAG1C,aAAa,CAAC,YAAY,CAAC;AACxC0C,MAAAA,MAAM,CAACnC,MAAM,CAACoC,IAAI,CAAC,IAAI,CAAC;AACxB,MAAA,IAAI,CAAC1C,WAAW,GAAGyC,MAAM,CAACzC,WAAW;AACvC;AACA,IAAA,IAAI,CAAC2C,IAAI,CAAC,WAAW,EAAE5B,SAAS,CAAC;AACnC;AACA4B,EAAAA,IAAIA,CAACV,KAA+B,EAAEW,KAAU,EAAE;IAChD,IAAI,IAAI,CAACZ,OAAO,EAAE;AAChB,MAAA;AACF;IACApB,WAAW,CAAC,IAAI,EAAE,MAAM;MACtB,IAAI;QACF,IAAIqB,KAAK,KAAK,WAAW,EAAE;UACzB,IAAI,CAACA,KAAK,GAAG,IAAI,CAACJ,SAAS,CAACgB,IAAI,CAACD,KAAK,CAAC;AACzC,SAAC,MAAM;AACL;AACA;UACA,IAAI,CAACX,KAAK,GAAG,IAAI,CAACJ,SAAS,CAACT,KAAK,CAAEwB,KAAK,CAAC;AAC3C;AACA,QAAA,IAAI,IAAI,CAACX,KAAK,CAACa,IAAI,EAAE;UACnB,IAAI,CAAChB,OAAO,CAAC,IAAI,CAACG,KAAK,CAACW,KAAK,CAAC;AAChC,SAAC,MAAM;AACLxC,UAAAA,OAAO,CAAC0B,OAAO,CAAC,IAAI,CAACG,KAAK,CAACW,KAAK,CAAC,CAACG,IAAI,CACnCH,KAAK,IAAK,IAAI,CAACD,IAAI,CAAC,WAAW,EAAEC,KAAK,CAAC,EACvCI,MAAM,IAAK,IAAI,CAACL,IAAI,CAAC,UAAU,EAAEK,MAAM,CAC1C,CAAC;AACH;OACD,CAAC,OAAOC,GAAG,EAAE;QACZ,IAAI,CAAChB,KAAK,GAAG;AACXa,UAAAA,IAAI,EAAE,IAAI;AACVF,UAAAA,KAAK,EAAE7B;SACR;AACD,QAAA,IAAI,CAACT,MAAM,CAAC4C,OAAO,CAAExD,YAAY,IAAK;UACpCA,YAAY,CAACN,IAAI,EAAE;AACrB,SAAC,CAAC;AACF,QAAA,IAAI,CAACsB,sBAAsB,CAACuC,GAAG,CAAC,EAAE;AAChC,UAAA,IAAI,CAAClB,MAAM,CAACkB,GAAG,CAAC;UAChB,IAAI,IAAI,CAACjD,WAAW,EAAE;AACpB,YAAA,IAAI,CAAC0B,YAAY,CAACyB,GAAG,CAACF,GAA2B,CAAC,EAAE;AAClDvB,cAAAA,YAAY,CAAC0B,GAAG,CAACH,GAA2B,CAAC;cAC7C,IAAI,CAACjD,WAAW,CAACqD,IAAI,CAAC,IAAI,EAAEJ,GAA2B,CAAC;AAC1D;AACF;AACF;AACF;AACF,KAAC,CAAC;AACJ;AACA7D,EAAAA,IAAIA,GAAG;IACL,IAAI,CAAC4C,OAAO,GAAG,IAAI;AACnB,IAAA,IAAI,IAAI,CAACC,KAAK,IAAIqB,SAAS,CAAC,IAAI,CAACrB,KAAK,CAACW,KAAK,CAAC,EAAE;AAC7CW,MAAAA,gBAAgB,CAAC,IAAI,CAACtB,KAAK,CAACW,KAAK,CAAC;AACpC;AACA,IAAA,IAAI,CAACtC,MAAM,CAAC4C,OAAO,CAAExD,YAAY,IAAK;MACpCA,YAAY,CAACN,IAAI,EAAE;AACrB,KAAC,CAAC;AACF,IAAA,IAAIG,CAAC,GAAG,IAAIC,KAAK,CAAC,iBAAiB,CAAC;IACpCD,CAAC,CAACE,OAAO,GAAG,iBAAiB;AAC7B,IAAA,IAAIS,UAAU,EAAE,KAAK,IAAI,EAAE;AACzB;AACA;AACA;AACA,MAAA,MAAMX,CAAC;AACT;AACA,IAAA,IAAIiE,CAAC,GAAG3C,OAAO,CAAC,IAAI,CAAC;AACrB,IAAA,IAAI2C,CAAC,EAAE;AACL;AACA;AACA;AACA;AACA;AACA;MACAA,CAAC,CAACpC,KAAK,GAAG7B,CAAC;AACb,KAAC,MAAM;AACL;AACA;MACAqB,WAAW,CAAC,IAAI,EAAE,MAAM6C,eAAe,CAAC,IAAI,CAAC5B,SAAS,CAAC,CAAC;AAC1D;AACF;AACF;AAEA,SAAS4B,eAAeA,CAAC5B,SAAoB,EAAE;AAC7C,EAAA,IAAItC,CAAC,GAAG,IAAIC,KAAK,CAAC,iBAAiB,CAAC;EACpCD,CAAC,CAACE,OAAO,GAAG,iBAAiB;EAC7B,IAAI;AACFoC,IAAAA,SAAS,CAACT,KAAK,CAAE7B,CAAC,CAAC;GACpB,CAAC,OAAO0D,GAAG,EAAE;AACZ,IAAA,IAAI,CAACvC,sBAAsB,CAACuC,GAAG,CAAC,EAAE;AAChC,MAAA,MAAMA,GAAG;AACX;AACF;AACF;AAEA,SAASK,SAASA,CAACI,KAAU,EAAyB;AACpD,EAAA,OAAOA,KAAK,IAAI,OAAOA,KAAK,CAACX,IAAI,KAAK,UAAU;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASY,QAAQA,CAAC,GAAGC,SAA0C,EAAE;EACtE,OAAO,UAAU,GAAGC,IAAW,EAAE;AAC/B;AACA,IAAA,OAAOzD,OAAO,CAACC,GAAG,CAACuD,SAAS,CAACrD,GAAG,CAAEuD,CAAC,IAAKA,CAAC,CAACC,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC,CAAC,CAAC;GAC9D;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,MAAMA,CAAC,GAAGJ,SAA0C,EAAE;EACpE,OAAO,UAAU,GAAGC,IAAW,EAAE;IAC/B,OAAO1E,UAAU,CAAC,aAAa;AAC7B,MAAA,KAAK,IAAIW,EAAE,IAAI8D,SAAS,EAAE;AACxB;AACA,QAAA,MAAM9D,EAAE,CAACiE,KAAK,CAAC,IAAI,EAAEF,IAAI,CAAC;AAC5B;AACF,KAAC,CAAC;GACH;AACH;;;;"}