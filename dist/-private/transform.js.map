{"version":3,"file":"transform.js","sources":["../../src/-private/transform.ts"],"sourcesContent":["/*\n  Our Transform type is always respresented relative to\n  `transform-origin: 0px 0px`. This is different from the browser's\n  own `transform` property, which will vary based on the present value\n  of `transform-origin`, and which defaults to `50% 50%`. I am\n  standardizing on zero because it disentangles our coordinate system\n  from the size of the element, which can vary over time.\n\n  Conceptually, each of our Transforms is a 2d affine transformation\n  representd as a 3x3 matrix:\n\n      a c tx\n      b d ty\n      0 0  1\n*/\n\nexport default class Transform {\n  constructor(\n    readonly a: number,\n    readonly b: number,\n    readonly c: number,\n    readonly d: number,\n    readonly tx: number,\n    readonly ty: number,\n  ) {}\n\n  serialize(): string {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`;\n  }\n\n  // See the comment below on `const identity`.\n  isIdentity(): boolean {\n    return (\n      this === identity ||\n      (this.a === 1 &&\n        this.b === 0 &&\n        this.c === 0 &&\n        this.d === 1 &&\n        this.tx === 0 &&\n        this.ty === 0)\n    );\n  }\n\n  mult(other: Transform): Transform {\n    // This is deliberately not isIdentity(). I'm optimizing for the\n    // case where there was no preexisting transform at all.\n    if (this === identity) {\n      return other;\n    }\n    if (other === identity) {\n      return this;\n    }\n    return new Transform(\n      this.a * other.a + this.c * other.b,\n      this.b * other.a + this.d * other.b,\n      this.a * other.c + this.c * other.d,\n      this.b * other.c + this.d * other.d,\n      this.a * other.tx + this.c * other.ty + this.tx,\n      this.b * other.tx + this.d * other.ty + this.ty,\n    );\n  }\n}\n\n// WARNING: this constant matrix exists as an optimization. But not\n// every no-op transform triple-equals this value. If you apply two\n// transforms that cancel each other out, you will get an identity\n// matrix but it will not triple-equal this one. And that is OK: we\n// use the triple-equality as an optimization only, not for\n// correctness.\n//\n// The optimization should be worthwhile because the majority of\n// things start out with no preexisting Transform, which we can\n// represent as `identity`, which will make identity.mult(something) a\n// no-op, etc.\nexport const identity = new Transform(1, 0, 0, 1, 0, 0);\n\nconst matrixPattern = /matrix\\((.*)\\)/;\n\nfunction parseTransform(matrixString: string): Transform {\n  const match = matrixPattern.exec(matrixString);\n  if (!match || !match[1]) {\n    return identity;\n  }\n  const [a, b, c, d, tx, ty] = match[1].split(',').map(parseFloat);\n  return new Transform(\n    a as number,\n    b as number,\n    c as number,\n    d as number,\n    tx as number,\n    ty as number,\n  );\n}\n\nfunction parseOrigin(originString: string): [number, number] {\n  return originString.split(' ').map(parseFloat) as [number, number];\n}\n\n/**\n  Returns a Transform instance representing the cumulative CSS\n  transform of this element and all its ancestors.\n\n  @function cumulativeTransform\n  @hide\n  @param {HTMLElement} elt\n  @return {Transform}\n*/\nexport function cumulativeTransform(elt: HTMLElement) {\n  let accumulator = null;\n  let current: HTMLElement | null = elt;\n  while (current && current.nodeType === 1) {\n    let transform = ownTransform(current);\n    if (transform !== identity && !transform.isIdentity()) {\n      if (accumulator) {\n        accumulator = transform.mult(accumulator);\n      } else {\n        accumulator = transform;\n      }\n    }\n    current = current.parentElement;\n  }\n  return accumulator || identity;\n}\n\n/**\n  Returns a Transform instance representing the CSS transform of this\n  element.\n\n * @function ownTransform\n * @param {HTMLElement} elt\n * @return {Transform} instance representing this element's css transform property.\n */\nexport function ownTransform(elt: HTMLElement): Transform {\n  let eltStyles = window.getComputedStyle(elt);\n  let t =\n    eltStyles.transform !== '' ? eltStyles.transform! : elt.style.transform!;\n  if (t === 'none') {\n    // This constant value is an optimization, and we rely on that in\n    // cumulativeTransform\n    return identity;\n  }\n  let matrix = parseTransform(t);\n  if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n    // If there is any rotation, scaling, or skew we need to do it within the context of transform-origin.\n    let origin =\n      eltStyles.getPropertyValue('transform-origin') !== ''\n        ? eltStyles.getPropertyValue('transform-origin')!\n        : elt.style.getPropertyValue('transform-origin')!;\n    let [originX, originY] = parseOrigin(origin);\n    if (originX === 0 && originY === 0) {\n      // transform origin is at 0,0 so it will have no effect, so we're done.\n      return matrix;\n    }\n\n    return new Transform(1, 0, 0, 1, originX, originY)\n      .mult(matrix)\n      .mult(new Transform(1, 0, 0, 1, -originX, -originY));\n  } else {\n    // This case is an optimization for when there is only translation.\n    return matrix;\n  }\n}\n"],"names":["Transform","constructor","a","b","c","d","tx","ty","serialize","isIdentity","identity","mult","other","matrixPattern","parseTransform","matrixString","match","exec","split","map","parseFloat","parseOrigin","originString","cumulativeTransform","elt","accumulator","current","nodeType","transform","ownTransform","parentElement","eltStyles","window","getComputedStyle","t","style","matrix","origin","getPropertyValue","originX","originY"],"mappings":"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"}